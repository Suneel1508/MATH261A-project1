---
title: "Pace Deficit & Starting Grid → Finishing Position in F1"
author: "Suneel Chandra Vanamu"
date: "10/06/2025"
abstract: "This paper asks a practical question in modern Formula 1: how do **on-day pace** (best-lap deficit) and **track position** (starting grid) each relate to where a driver **finishes**? The motivation is simple—teams invest heavily in qualifying for clean air, and race commentary constantly points to raw speed—so a simple, single-number relationship can be useful without complex models. Using the public **F1DB** CSV release (2014–present), I fit two single-predictor linear regressions: best-lap deficit → finishing position, and grid position → finishing position. The grid model shows a stronger, steadier link; the pace model is meaningful but noisier. I report **R²/adj-R²**, **residual standard error (positions)**, **slope + 95% CI**, and basic diagnostics."
research_question: "How do a driver's best-lap pace deficit and starting grid position each relate to their finishing position in F1 races (2014–present)?"
format:
  pdf:
    fontsize: 10pt
    fig-width: 5.2
    fig-height: 3.2  
number-sections: true
bibliography: "references.bib"
editor: visual
---

```{r}
#| include: false
#| warning: false
#| message: false
library(tidyverse)
library(readr)
library(dplyr)
library(ggplot2)
library(reshape2)
library(gridExtra)
library(broom)
library(knitr)
```

# Introduction {#sec-introduction}

Formula 1 results can hinge on many moving parts—strategy, traffic, weather—but two simple signals are always front and center: **raw pace** and **track position**. This paper asks a single, practical question: How do a driver’s **best-lap pace deficit** and **starting grid position** each affect where they **finish**? In plain terms, if a driver is slower on their best lap, or if they start farther back, do they tend to finish farther back as well?

This question matters because teams pour effort into **qualifying** for clean air, and commentators constantly point to **speed** as the difference-maker. A clear, one-number relationship helps analysts discuss race outcomes without building complex models. To make fair comparisons across circuits and seasons, I focus on the **2014–present hybrid era** and use **finishing position** as the common outcome (**1 = winner**). Pace is measured as the gap between a driver’s best race lap and the race’s fastest lap (**“best-lap deficit,” in seconds**). **Starting grid position** is the driver’s place on the grid at lights out.

Using the **F1DB CSV** release, I assemble a driver–race table for this era and fit two **one-predictor linear regressions**: (1) **best-lap deficit → finishing position**, and (2) **starting grid position → finishing position**. For each model I report how tightly the predictor lines up with finishing order (**R²/adjusted R²**), the model’s typical miss in positions (**residual standard error**), and the average change in finishing place for a one-unit change in the predictor (**slope with a 95% confidence interval**). I also include simple **scatterplots** with a **regression line** and basic **residual checks**.

The remainder of this paper is organized as follows. **Section 2** describes the dataset and key variables. **Section 3** provides bivariate analysis. **Section 4** builds and evaluates the best-lap-deficit and starting-grid models. **Section 5** discusses the results and their interpretation. **Section 6** summarizes main takeaways, practical implications, and brief robustness ideas.

**Project repository:** <https://github.com/Suneel1508/MATH261A-project1>

# Data and Variables {#sec-data-variables}

I use the public F1DB dataset [@f1db-github]. Files are read with readr [@readr-2024], tidied with janitor [@janitor-2023] and tidyr [@tidyr-2024], and string fields parsed with stringr [@stringr-2023]. Visuals use ggplot2 [@ggplot2-book-2016] within R [@R-base-2024]. To keep things comparable across tracks and seasons, I focus on the 2014–present hybrid era. For each driver in each race, I pull three core fields:

-   Finishing position (response): integer rank, where 1 = winner.
-   Best-lap pace deficit (sec) (predictor A): how much slower a driver’s best race lap was compared with the race’s fastest lap (small, continuous values in seconds).
-   Starting grid position (predictor B): integer rank at the start lights (1 = pole, higher = farther back).

```{r}
#| include: false
#| warning: false
#| message: false
#| echo: false

# Path to our CSVs
data_dir <- "/Users/spartan/Desktop/Math 261/Project 1/F1_Datasets_for_Project"

suppressPackageStartupMessages({
  library(tidyverse); library(readr); library(janitor); library(stringr); library(broom)
})

# Load F1DB CSVs
races <- read_csv(file.path(data_dir, "f1db-races.csv")) |> clean_names()
res   <- read_csv(file.path(data_dir, "f1db-races-race-results.csv")) |> clean_names()
fast  <- read_csv(file.path(data_dir, "f1db-races-fastest-laps.csv")) |> clean_names()

# Keep 2014+ era and the rank fields we need — from res only
res_era <- res %>%
  dplyr::filter(year >= 2014) %>%
  dplyr::select(race_id, driver_id, year,
                finish_pos = position_number,
                grid_pos   = grid_position_number)


# Helper: parse "M:SS.sss" or "SS.sss" to seconds
parse_lap_seconds <- function(x){
  y <- str_trim(x); y[is.na(y)] <- NA_character_
  secs <- rep(NA_real_, length(y))
  m <- str_match(y, "([0-9]+):([0-9]+\\.?[0-9]*)")
  if (!all(is.na(m[,1]))) {
    idx <- !is.na(m[,1]); secs[idx] <- as.numeric(m[idx,2])*60 + as.numeric(m[idx,3])
  }
  s <- str_match(y, "^([0-9]+\\.?[0-9]*)s?$")
  if (!all(is.na(s[,1]))) {
    idx2 <- is.na(secs) & !is.na(s[,1]); secs[idx2] <- as.numeric(s[idx2,2])
  }
  secs
}

# Ensure fastest-laps have numeric milliseconds
if (!"time_millis" %in% names(fast) && "time" %in% names(fast)) {
  fast <- fast |> mutate(time_millis = parse_lap_seconds(time)*1000)
}

# Build pace-deficit (driver best lap minus race fastest, in seconds)
best_lap <- fast |>
  group_by(race_id, driver_id) |>
  summarise(best_lap_ms = min(time_millis, na.rm = TRUE), .groups = "drop") |>
  filter(is.finite(best_lap_ms))

race_fast <- best_lap |>
  group_by(race_id) |>
  summarise(race_fast_ms = min(best_lap_ms, na.rm = TRUE), .groups = "drop")

pace <- best_lap |>
  left_join(race_fast, by = "race_id") |>
  mutate(best_lap_delta_sec = (best_lap_ms - race_fast_ms)/1000) |>
  select(race_id, driver_id, best_lap_delta_sec)

# Modeling tables
df_pace_pos <- res_era |>
  left_join(pace, by = c("race_id","driver_id")) |>
  filter(is.finite(finish_pos), is.finite(best_lap_delta_sec)) |>
  distinct(race_id, driver_id, .keep_all = TRUE)

df_grid_pos <- res_era |>
  filter(is.finite(finish_pos), is.finite(grid_pos)) |>
  distinct(race_id, driver_id, .keep_all = TRUE)
```

```{r}
#| include: false
#| warning: false
#| message: false
#| echo: false
# Quick peek and missingness for key fields
head(df_pace_pos[, c("race_id","driver_id","year","best_lap_delta_sec","finish_pos")], 6)

sapply(df_pace_pos[, c("best_lap_delta_sec","finish_pos")], function(v) sum(is.na(v)))
sapply(df_grid_pos[, c("grid_pos","finish_pos")], function(v) sum(is.na(v)))

summary(df_pace_pos$best_lap_delta_sec)
summary(df_grid_pos$grid_pos)
summary(df_grid_pos$finish_pos)
```

```{r}
#| echo: false
#| warning: false
# Visual summaries

pal <- list(
  pace   = "#5DA5A4",  # muted teal
  grid   = "#A87C9F",  # dusty purple
  finish = "#C4A46B",  # warm sand
  line   = "#5C6B8A",  # steel blue for outlines
  text   = "#2F343B",  # dark gray
  gridln = "#E9ECEF"   # light grid
)

theme_clean <- function() {
  theme_minimal(base_size = 12) +
    theme(
      plot.title    = element_text(face = "bold", color = pal$text),
      axis.title.x  = element_text(color = pal$text),
      axis.title.y  = element_text(color = pal$text),
      axis.text     = element_text(color = pal$text),
      panel.grid    = element_line(color = pal$gridln, linewidth = 0.4),
      panel.grid.minor = element_blank(),
      panel.grid.major.x = element_line(color = pal$gridln),
      panel.grid.major.y = element_line(color = pal$gridln)
    )
}

# 1) Best-lap deficit — histogram + density
p_def_hist <- ggplot(df_pace_pos, aes(best_lap_delta_sec)) +
  geom_histogram(aes(y = after_stat(..density..)),
                 bins = 40, fill = pal$pace, color = pal$line, alpha = 0.55) +
  geom_density(linewidth = 0.9, color = pal$line) +
  labs(title = "Best-Lap Deficit: Histogram + Density",
       x = "seconds", y = "density") +
  theme_clean()

# 2) Best-lap deficit — ECDF
p_def_ecdf <- ggplot(df_pace_pos, aes(best_lap_delta_sec)) +
  stat_ecdf(geom = "step", linewidth = 1.0, color = pal$line) +
  labs(title = "Best-Lap Deficit: ECDF",
       x = "seconds", y = "F(x)") +
  theme_clean()

# 3) Starting grid position — bar chart (discrete)
p_grid_bar <- ggplot(df_grid_pos, aes(factor(grid_pos))) +
  geom_bar(fill = pal$grid, color = pal$line, alpha = 0.85, width = 0.85) +
  labs(title = "Starting Grid Position: Counts",
       x = "grid position (1 = pole)", y = "count") +
  theme_clean()

# 4) Finishing position — bar chart (discrete)
p_finish_bar <- ggplot(df_grid_pos, aes(factor(finish_pos))) +
  geom_bar(fill = pal$finish, color = pal$line, alpha = 0.85, width = 0.85) +
  labs(title = "Finishing Position: Counts",
       x = "finishing position (1 = winner)", y = "count") +
  theme_clean()
```

```{r}
#| warning: false
#| message: false
#| echo: false
#| label: Figure1:fig-def-hist
#| fig-cap: "Distribution of best-lap deficit (2014–present). Most drivers sit within a few seconds of the race’s fastest lap; a long right tail reflects incidents and traffic."
p_def_hist
```

```{r}
#| warning: false
#| message: false
#| echo: false
#| label: Figure2:fig-def-ecdf
#| fig-cap: "ECDF of best-lap deficit. About half the field is within ~1–1.5s of the fastest lap; only a small fraction exceed ~3–4s."
p_def_ecdf

```

The **best-lap deficit** is continuous and measured in seconds, so I show its **histogram with a density curve** and an **ECDF**. The histogram suggests most drivers’ best laps sit within a small band—roughly a couple of seconds—of the race’s fastest lap, with a **right-hand tail** of larger deficits (cars in traffic, tire issues, etc.). The **ECDF** (Empirical Cumulative Distribution Function) reads like a running total: at any x-value on the horizontal axis, the y-value shows the **fraction of drivers whose deficit is ≤ x seconds**. The smooth S-shape you see means deficits accumulate steadily, with very few extreme outliers.

```{r}
#| warning: false
#| message: false
#| echo: false
#| label: Figure3:fig-grid-bar
#| fig-cap: "Starting grid positions used (2014–present). Discrete ranks produce vertical bands in later scatterplots."
p_grid_bar

```

```{r}
#| warning: false
#| message: false
#| echo: false
#| label: Figure4:fig-finish-bar
#| fig-cap: "Finishing positions (1 = winner). Winners create a spike at 1; mass spreads gradually toward the midfield and backmarkers."
p_finish_bar

```

The other two variables are **discrete ranks**, so I use **bar charts** instead of box plots. The **Starting Grid Position** plot is fairly spread across the grid, which is what we expect over many races. The **Finishing Position** plot naturally **tapers at the back** because not every race classifies all 20–22 cars; retirements and lap-downs thin out the tail. These bars make it clear we’re modeling integer outcomes, and they also hint that moving from, say, P4 to P6 is not the same kind of jump as moving from P18 to P20 in terms of frequency.

A few light data steps sit behind these pictures. I join race results to the fastest-laps table to compute the **best-lap deficit** per driver per race, then keep a **single row per driver–race** with the three fields above. I also restrict to the hybrid era using the provided year field. This keeps things apples-to-apples across circuits and seasons without introducing extra adjustments.

These visuals do two jobs. First, they **set scale**: finishing position is an integer rank, grid is an integer rank, and pace deficit is a small, continuous number measured in seconds. Second, they **flag shape**: pace deficits are right-skewed, while grid/finish are count-based. With this context in place, Section 3 takes the next step—a quick look at how each predictor lines up with finishing position—before we fit the two simple regressions.

**Missingness & filters.** I keep one row per driver–race in 2014+ with **numeric finishing position** and the predictor needed for each model. Practically, that means I require finite values for `position_number` (removing DNS/DSQ/DNF entries lacking a numeric finish), `best_lap_delta_sec` for pace models, and `gap_sec` for gap models. Winners have `gap_sec = 0` by definition. This ensures summaries and fits are based on complete, comparable records.

# Quick Bivariate EDA

Before fitting any models, I want to quickly visualize how each predictor relates to finishing position, as well as check for any relationship between the two predictors themselves, using ggplot2[@ggplot2-book-2016] and dplyr[@dplyr-2023]. This isn’t about proving anything yet—it’s just a check for the direction of the trend, amount of spread, and any obvious curvature or outliers. I’ll plot (a) **best-lap deficit → finish**, (b) **grid → finish**, and (c) **grid ↔ best-lap deficit** with simple rank-based correlations.

```{r}
#| include: false
#| warning: false
#| message: false
#| echo: false

# Subtle palette + lightweight theme (define if not already defined)
if (!exists("pal")) {
  pal <- list(
    pace   = "#5DA5A4",  # muted teal
    grid   = "#A87C9F",  # dusty purple
    finish = "#C4A46B",  # warm sand
    line   = "#5C6B8A",  # steel blue
    text   = "#2F343B",  # dark gray
    gridln = "#E9ECEF"   # light grid
  )
}
if (!exists("theme_clean")) {
  theme_clean <- function() {
    ggplot2::theme_minimal(base_size = 12) +
      ggplot2::theme(
        plot.title        = ggplot2::element_text(face = "bold", color = pal$text),
        axis.title.x      = ggplot2::element_text(color = pal$text),
        axis.title.y      = ggplot2::element_text(color = pal$text),
        axis.text         = ggplot2::element_text(color = pal$text),
        panel.grid        = ggplot2::element_line(color = pal$gridln, linewidth = 0.4),
        panel.grid.minor  = ggplot2::element_blank()
      )
  }
}
```

## Best-lap deficit → finishing position

```{r}
#| warning: false
#| message: false
#| echo: false
p_pace_finish_pts <- ggplot(df_pace_pos, aes(best_lap_delta_sec, finish_pos)) +
  geom_jitter(width = 0, height = 0.20, alpha = 0.35, color = pal$pace) +
  labs(title = "Finishing Position vs Best-Lap Deficit — 2014+",
       x = "Best-lap deficit to race fastest (seconds)",
       y = "Finishing position (1 = winner)") +
  theme_clean()
```

```{r}
#| warning: false
#| message: false
#| echo: false
#| label: Figure5:fig-eda-pace-finish
#| fig-cap: "Finishing position vs best-lap deficit (points only). Clear upward tilt—larger deficits usually mean worse finishes—but with wide spread."
p_pace_finish_pts
```

The cloud **tilts upward**: larger best-lap deficits generally pair with **worse finishing positions**. The signal is there, but the spread is wide—at the same deficit you can land anywhere from the top ten to the teens. Near **zero deficit**, many finishes cluster toward the front but it’s not guaranteed (traffic/strategy can shuffle results). Past roughly **3–4 seconds**, front-running finishes are uncommon, which matches intuition. Overall: a **meaningful but noisy** relationship; a simple linear fit later should capture the direction, with only **moderate** R².

## Starting grid position → finishing position

```{r}
#| warning: false
#| message: false
#| echo: false
p_grid_finish_pts <- ggplot(df_grid_pos, aes(grid_pos, finish_pos)) +
  geom_jitter(width = 0.20, height = 0.20, alpha = 0.35, color = pal$grid) +
  labs(title = "Finishing Position vs Starting Grid — 2014+",
       x = "Starting grid position (1 = pole)",
       y = "Finishing position (1 = winner)") +
  theme_clean()
```

```{r}
#| warning: false
#| message: false
#| echo: false
#| label: Figure6:fig-eda-grid-finish
#| fig-cap: "Finishing position vs starting grid (points only). A staircase pattern: deeper grid slots generally align with worse finishes."
p_grid_finish_pts
```

There’s a clear **staircase pattern**: as **grid position increases**, finishing positions also rise. The vertical stripes are just the grid being discrete; what stands out is how the point bands climb steadily from left to right. Compared with the pace plot, the spread is **tighter**, especially near the front rows—track position really helps. I’d expect a **stronger fit** here (higher R² and a smaller residual error in positions) than in the pace-deficit model.

## Are the predictors related?

```{r}
#| warning: false
#| message: false
#| echo: false
df_pp <- inner_join(
  df_grid_pos |> select(race_id, driver_id, grid_pos),
  df_pace_pos |> select(race_id, driver_id, best_lap_delta_sec),
  by = c("race_id","driver_id")
)
cor_table <- tibble(
  Spearman = cor(df_pp$grid_pos, df_pp$best_lap_delta_sec, method = "spearman", use = "complete.obs"),
  Kendall  = cor(df_pp$grid_pos, df_pp$best_lap_delta_sec, method = "kendall",  use = "complete.obs")
)
```

```{r}
#| warning: false
#| message: false
#| echo: false
#| label: Figure7:Correlation Table
#| fig-cap: "Rank correlations (Spearman, Kendall) between grid and best-lap deficit. Moderate positive values indicate a same-direction tendency without assuming linearity."
cor_table
```

The jitter plot **leans upward**, and the rank correlations back it up: **Spearman ≈ 0.51** and **Kendall ≈ 0.37** indicate a **moderate positive association**. In plain terms, cars that start farther back often also have a larger pace deficit—but the link isn’t tight enough to call them duplicates. Each predictor carries **distinct information** about finishing order.

***Why these?*** Spearman (ρ) and Kendall (τ) are **rank-based** correlation measures: they capture **monotonic** association without assuming linearity and are robust to outliers. Here they summarize whether starting deeper on the grid tends to go with a larger pace deficit; moderate positive values mean “usually yes,” but not a one-to-one link.

```{r}
#| warning: false
#| message: false
#| echo: false
p_predpred_pts <- ggplot(df_pp, aes(grid_pos, best_lap_delta_sec)) +
  geom_jitter(width = 0.20, height = 0, alpha = 0.25, color = pal$finish) +
  labs(title = "Grid vs Best-Lap Deficit",
       x = "Starting grid position (1 = pole)",
       y = "Best-lap deficit (seconds)") +
  theme_clean()
```

```{r}
#| warning: false
#| message: false
#| echo: false
#| label: Figure8:fig-eda-grid-vs-def
#| fig-cap: "Starting grid vs best-lap deficit. Moderate positive association: cars starting farther back often have larger pace deficits, but not one-to-one."
p_predpred_pts
```

Linear fits are reasonable (no obvious curvature), but we should expect **grid → finish** to explain more variance than **pace → finish**. We’ll quantify that in Results with **R²**, **residual standard error (positions)**, and **slope + 95% CI**, and we’ll add residual plots to check assumptions.

# Methods

To answer the question “How do a driver’s best-lap pace deficit and starting grid position each affect **finishing position**?”, I fit **two separate one-predictor linear regressions** on the 2014–present data. I keep the setup simple on purpose so the effects are easy to read in plain units (positions and seconds).

## Model A — Best-lap pace deficit → Finishing position

Let $\text{FinishPos}_i​$ be driver $i’s$ finishing position ($1$ = winner) and $\text{Deficit}_i$​ the driver’s best-lap pace deficit in seconds (their best race lap minus the race’s fastest lap). I fit a simple line:

$$
\text{FinishPos}_i=\beta_0+\beta_1*\text{Deficit}_i+\varepsilon_i
$$

Here, ${\beta}$ is the line’s intercept (the model’s expected finishing position when the deficit is zero—i.e., when a driver’s best lap matches the day’s fastest lap). ${\beta}_1$​ is the **average change in finishing position per +1 second** of deficit (e.g., ${\beta}_1 =1.4$​ means \~1.4 places farther back for each extra second). The error term ${\varepsilon}_i$​ captures race noise we’re not modeling (strategy, safety cars, incidents). I’ll report **R²/adj-R²**, **Residual SE** (typical miss, in positions), **Residual SE²**, and the **slope with 95% CI**.

```{r}
#| include: false
#| warning: false
#| message: false
#| echo: false
mod_pace_pos   <- lm(finish_pos ~ best_lap_delta_sec, data = df_pace_pos)
tidy_pace_pos  <- broom::tidy(mod_pace_pos, conf.int = TRUE)
gl_pace_pos    <- broom::glance(mod_pace_pos)
rse_pace_pos   <- summary(mod_pace_pos)$sigma
metrics_pace   <- tibble(Model="A: Best-lap deficit → finish",
                         n=gl_pace_pos$nobs, r2=gl_pace_pos$r.squared,
                         adj_r2=gl_pace_pos$adj.r.squared,
                         rse_pos=rse_pace_pos, rse_sq=rse_pace_pos^2)
aug_pace_pos   <- broom::augment(mod_pace_pos)

```

## Model B — Starting grid position → Finishing position

Let $\text{FinishPos}_i​$ be finishing position and $\text{Grid}_i$ the starting grid slot (1 = pole; higher = farther back). The model is:

$$
\text{FinishPos}_i=\gamma_0+\gamma_1\,\text{Grid}_i+\eta_i
$$

Here, ${\gamma}_1$​ is the **average change in finishing position per one grid place farther back** (we expect a positive slope: deeper grid → worse finish). $\gamma_0$​ is the intercept; since grid starts at 1, it mainly anchors the line and is most interpretable near the observed range (e.g., predicted finish at grid ≈ 1–2). As with Model A, I’ll summarize **R²/adj-R²**, **Residual SE** (positions) and its square, plus the **slope with 95% CI** to show effect size and uncertainty.

```{r}
#| warning: false
#| message: false
#| echo: false
mod_grid_pos   <- lm(finish_pos ~ grid_pos, data = df_grid_pos)
tidy_grid_pos  <- broom::tidy(mod_grid_pos, conf.int = TRUE)
gl_grid_pos    <- broom::glance(mod_grid_pos)
rse_grid_pos   <- summary(mod_grid_pos)$sigma
metrics_grid   <- tibble(Model="B: Grid → finish",
                         n=gl_grid_pos$nobs, r2=gl_grid_pos$r.squared,
                         adj_r2=gl_grid_pos$adj.r.squared,
                         rse_pos=rse_grid_pos, rse_sq=rse_grid_pos^2)
aug_grid_pos   <- broom::augment(mod_grid_pos)
```

I use ordinary least squares via `lm()` in R[@R-base-2024]; report rendered with **knitr** [@knitr-2024]. These one-variable models assume a roughly linear average effect and approximately constant spread of residuals; I’ll check standard residual plots in Results. Because we use just one predictor at a time, the goal is clarity: quantify how much **one simple number** (pace deficit or grid slot) moves finishing position, in **positions per second** or **positions per grid place**, while acknowledging unmodeled race factors.

# Results

We report results for two simple regressions on the 2014–present era:

-   \(A\) **Best-lap pace deficit → finishing position**
-   \(B\) **Starting grid position → finishing position**.

For each, I summarize the slope (effect size), how much variance is explained (R²/adjusted R²), and the model’s typical miss in positions (Residual Standard Error, RSE). The fitted red-line scatters and residual diagnostics appear below the tables.

## Best-lap deficit → finishing position

According to the model, the average change in finishing place per +1s of pace deficit is **`r round(tidy_pace_pos$estimate[ tidy_pace_pos$term=="best_lap_delta_sec" ], 3)`** positions (95% CI **\[`r round(tidy_pace_pos$conf.low[ tidy_pace_pos$term=="best_lap_delta_sec" ], 3)`, `r round(tidy_pace_pos$conf.high[ tidy_pace_pos$term=="best_lap_delta_sec" ], 3)`\]**). The fit explains **`r round(metrics_pace$r2, 3)`** of the variation in finishing order (adjusted R² = **`r round(metrics_pace$adj_r2, 3)`**), with a Residual SE of **`r round(metrics_pace$rse_pos, 2)`** positions (variance **`r round(metrics_pace$rse_sq, 2)`**). In plain terms, if the line predicts P9, results often land roughly **P9 ± `r round(metrics_pace$rse_pos, 1)`**. This matches the earlier points-only plot: pace is meaningful but noisy.

```{r}
#| warning: false
#| message: false
#| echo: false
p_pace_finish <- ggplot(df_pace_pos, aes(best_lap_delta_sec, finish_pos)) +
  geom_jitter(width = 0, height = 0.20, alpha = 0.35, color = pal$pace) +
  geom_smooth(method = "lm", se = TRUE, color = "red") +
  labs(title = "Finishing Position vs Best-Lap Deficit — 2014+",
       x = "Best-lap deficit (sec)", y = "Finishing position (1 = winner)") +
  theme_clean()
```

```{r}
#| warning: false
#| message: false
#| echo: false
#| label: Figure9:fig-res-pace-finish
#| fig-cap: "Finishing position vs best-lap deficit with linear fit. Upward slope quantifies positions lost per second of deficit; variability reflects race dynamics."
p_pace_finish

```

## Starting grid position → finishing position

Here the slope is **`r round(tidy_grid_pos$estimate[ tidy_grid_pos$term=="grid_pos" ], 3)`** positions per one grid place farther back (95% CI **\[`r round(tidy_grid_pos$conf.low[ tidy_grid_pos$term=="grid_pos" ], 3)`, `r round(tidy_grid_pos$conf.high[ tidy_grid_pos$term=="grid_pos" ], 3)`\]**). The model explains **`r round(metrics_grid$r2, 3)`** of finishing-order variation (adjusted R² = **`r round(metrics_grid$adj_r2, 3)`**), with a Residual SE of **`r round(metrics_grid$rse_pos, 2)`** positions (variance **`r round(metrics_grid$rse_sq, 2)`**). That tighter error and higher R² are consistent with the staircase we saw in the points-only plot: track position is a strong, steady signal.

```{r}
#| warning: false
#| message: false
#| echo: false
p_grid_finish <- ggplot(df_grid_pos, aes(grid_pos, finish_pos)) +
  geom_jitter(width = 0.20, height = 0.20, alpha = 0.35, color = pal$grid) +
  geom_smooth(method = "lm", se = TRUE, color = "red") +
  labs(title = "Finishing Position vs Starting Grid — 2014+",
       x = "Starting grid (1 = pole)", y = "Finishing position (1 = winner)") +
  theme_clean()
```

```{r}
#| warning: false
#| message: false
#| echo: false
#| label: Figure10:fig-res-grid-finish
#| fig-cap: "Finishing position vs starting grid with linear fit. Stronger, steadier upward trend than the pace plot; discrete grid slots create vertical bands."
p_grid_finish
```

The residuals-vs-fitted plots should look like centered bands without strong funnels.

```{r}
#| warning: false
#| message: false
#| echo: false
# Tables: model summaries + slopes with CI
metrics_combined <- bind_rows(metrics_pace, metrics_grid)
knitr::kable(
  metrics_combined |> mutate(
    r2 = round(r2, 3), adj_r2 = round(adj_r2, 3),
    rse_pos = round(rse_pos, 3), rse_sq = round(rse_sq, 3)
  ),
  caption = "Model summaries (n, R², adjusted R², residual SE in positions, residual variance)."
)

coef_table <- bind_rows(
  tidy_pace_pos |> mutate(Model = "A: Best-lap deficit → finish"),
  tidy_grid_pos |> mutate(Model = "B: Grid → finish")
) |>
  filter(term != "(Intercept)") |>
  transmute(
    Model,
    Term = recode(term,
                  best_lap_delta_sec = "Best-lap deficit (sec)",
                  grid_pos = "Starting grid position"),
    Estimate = round(estimate, 3),
    `Std. Error` = round(std.error, 3),
    `CI low` = round(conf.low, 3),
    `CI high` = round(conf.high, 3)
  )
knitr::kable(coef_table, caption = "Slope estimates (effect on finishing position) with 95% CIs.")
```

```{r}
#| warning: false
#| message: false
#| echo: false
# Residual diagnostics
p_resid_pace <- ggplot(aug_pace_pos, aes(.fitted, .resid)) +
  geom_point(alpha = .3) +
  geom_hline(yintercept = 0, linetype = 2) +
  labs(title = "Residuals vs Fitted — Best-Lap Deficit → Finish",
       x = "Fitted finish position", y = "Residuals") +
  theme_clean()
```

```{r}
#| warning: false
#| message: false
#| echo: false
#| label: Figure11:fig-resid-pace
#| fig-cap: "Residuals vs fitted — Best-lap deficit model. Band centered near zero; mild structure at extremes consistent with bounded ranks."
p_resid_pace
```

```{r}
#| warning: false
#| message: false
#| echo: false
p_resid_grid <- ggplot(aug_grid_pos, aes(.fitted, .resid)) +
  geom_point(alpha = .3) +
  geom_hline(yintercept = 0, linetype = 2) +
  labs(title = "Residuals vs Fitted — Grid → Finish",
       x = "Fitted finish position", y = "Residuals") +
  theme_clean()
```

```{r}
#| warning: false
#| message: false
#| echo: false
#| label: Figure12:fig-resid-grid
#| fig-cap: "Residuals vs fitted — Grid model. Tighter, more horizontal band; no strong funnel, supporting a simple linear mean."
p_resid_grid
```

Both residual plots show the expected **striping** from an integer outcome, but the points stay **centered around zero** overall. In the **pace → finish** model there’s a **slight negative tilt**—the model is a bit optimistic for very strong predicted finishes and a bit pessimistic for weak ones—likely from the bounded scale and mild nonlinearity. The **grid → finish** band is **tighter and more horizontal**, with only small spreading at the extremes. Importantly, there’s **no strong funnel or curvature**, so a linear mean with roughly constant variance is reasonable. For this project’s one-predictor goal, the diagnostics look **acceptable**.

# Discussion

This study used two simple linear regressions to see how **on-day pace** (best-lap deficit) and **track position** (starting grid slot) relate to **finishing position** in modern F1. Both signals matter, but the results are clear: **grid position is the stronger, steadier predictor**, while **pace deficit has a meaningful but noisier link**—consistent with what we saw in the bivariate plots and residual checks.

There are limits. I only analyzed the hybrid-era subset and used **one predictor at a time**, so I don’t control for track layout, safety cars, tyre strategy, team/driver strength, or weather. Finishing position is an **integer and bounded**, so a straight line can’t capture every wrinkle. Best-lap deficit is also a **single-lap snapshot** of pace rather than race-long speed.

Future work could fold in **track or season effects**, team/driver indicators, or **per-lap average pace**. Still, the takeaway for this project is practical and readable: **starting closer to the front reliably pulls the finish forward**, and **being even a second off the day’s fastest lap tends to push it back**—quantified in plain units of **positions per grid place** and **positions per second**.

# References
